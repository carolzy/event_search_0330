import logging
from datetime import datetime
import json
import re
import uuid
from pathlib import Path
from typing import List, Dict, Optional, Any

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class FlowController:
    def __init__(self):
        """Initialize flow controller with startup-focused setup"""
        self.user_id = f"user_{uuid.uuid4().hex[:8]}"
        self.keywords = []
        self.conversation_history = []
        self.product_description = ""
        self.target_market = ""
        self.differentiators = ""
        self.company_stage = ""
        self.location = ""
        self.linkedin = ""
        
        # Initialize keyword patterns
        self.keyword_patterns = {
            'industry': [
                r'software', r'fintech', r'healthcare', r'retail', 
                r'manufacturing', r'education', r'insurance', r'banking'
            ],
            'gtm': [
                r'sales', r'marketing', r'direct', r'channel', 
                r'partner', r'reseller', r'distributors'
            ],
            'market_indicators': [
                r'growing', r'competitive', r'saturated', r'emerging',
                r'disrupting', r'scaling', r'enterprise', r'smb'
            ]
        }
        
        # Updated question templates with correct questions
        self.question_templates = {
            'product': "What product or service do you sell?",
            'market': "What market or industry do you target?",
            'differentiation': "What makes your product unique compared to competitors?",
            'company_size': "What size companies do you typically sell to? (e.g., SMB, Mid-Market, Enterprise)",
            'location': "What zip code are you in? This helps us suggest local events. (You can skip this)",
            'linkedin': "Would you like to connect your LinkedIn account to improve recommendations?",
            'complete': "Awesome! I've gathered everything I need. Let's find some great companies for you."
        }
        
        # Dynamically determine the next question based on responses
        self.dynamic_flow = {
            'product': self._determine_next_after_product,
            'market': self._determine_next_after_market,
            'differentiation': self._determine_next_after_differentiation,
            'company_size': self._determine_next_after_company_size,
            'location': self._determine_next_after_location,
            'linkedin': lambda _: 'complete'
        }

    async def reset(self):
        """Reset all conversation state"""
        self.__init__()
        logger.info(f"Reset state for user {self.user_id}")
        return True

    async def generate_personalized_response(self, step: str) -> str:
        """Generate a personalized response based on the current step and user data."""
        if step == 'product':
            return f"Tell me more about your {self.product_description}"
        elif step == 'market':
            return f"Who do you target in the {self.target_market} market?"
        elif step == 'differentiation':
            return f"What makes your product unique compared to others in the {self.target_market} market?"
        # Add more personalized responses for other steps as needed
        else:
            return "Let's move on to the next question."

    # Dynamic flow determination methods
    def _determine_next_after_product(self, answer: str) -> str:
        """Determine next question after product description"""
        industry_keywords = self._extract_with_patterns(answer, patterns_category='industry')
        if len(industry_keywords) >= 2:
            logger.info(f"Detected industry in product description: {industry_keywords}")
            return 'differentiation'
        return 'market'
    
    def _determine_next_after_market(self, answer: str) -> str:
        """Determine next question after market description"""
        gtm_keywords = self._extract_with_patterns(answer, patterns_category='gtm')
        if len(gtm_keywords) >= 2:
            logger.info(f"Detected GTM info in market description: {gtm_keywords}")
            return 'company_size'
        return 'differentiation'
    
    def _determine_next_after_differentiation(self, answer: str) -> str:
        """Determine next question after differentiation"""
        market_indicators = self._extract_with_patterns(answer, patterns_category='market_indicators')
        if len(market_indicators) >= 2:
            logger.info(f"Detected market indicators in differentiation: {market_indicators}")
            return 'location'
        return 'company_size'
    
    def _determine_next_after_company_size(self, answer: str) -> str:
        """Determine next question after company size"""
        return 'location'
    
    def _determine_next_after_location(self, answer: str) -> str:
        """Determine next question after location"""
        if not answer or len(answer.split()) <= 2:
            logger.info("Location skipped or minimal, skipping LinkedIn")
            return 'complete'
        return 'linkedin'

    def _extract_with_patterns(self, text: str, patterns_category: Optional[str] = None) -> List[str]:
        """Extract business terms using predefined patterns"""
        if not text:
            return []
            
        text = text.lower()
        found_terms = []
        
        if patterns_category:
            if patterns_category in self.keyword_patterns:
                patterns = self.keyword_patterns[patterns_category]
                for pattern in patterns:
                    if re.search(pattern, text):
                        found_terms.append(patterns_category.replace('_', ' '))
                        break
        else:
            for category, patterns in self.keyword_patterns.items():
                for pattern in patterns:
                    if re.search(pattern, text):
                        found_terms.append(category.replace('_', ' '))
                        break
        
        return found_terms
        
    def extract_keywords(self, text: str) -> List[str]:
        """Extract keywords from text using patterns and NLP techniques"""
        if not text:
            return []
        
        # Use the existing pattern extraction method
        all_keywords = []
        for category in self.keyword_patterns.keys():
            terms = self._extract_with_patterns(text, category)
            all_keywords.extend(terms)
        
        # Add simple word extraction for common business terms
        words = re.findall(r'\b\w+\b', text.lower())
        business_terms = ['business', 'customer', 'product', 'service', 'market', 
                          'solution', 'technology', 'platform', 'data', 'analytics',
                          'cloud', 'saas', 'api', 'integration', 'automation']
        
        for word in words:
            if word in business_terms and word not in all_keywords:
                all_keywords.append(word)
        
        return all_keywords

    async def store_answer(self, step: str, answer: str):
        """Store answer with enhanced keyword extraction"""
        if step == "product":
            self.product_description = answer
        elif step == "market":
            self.target_market = answer
        elif step == "differentiation":
            self.differentiators = answer
        elif step == "company_size":
            self.company_stage = answer
        elif step == "location":
            self.location = answer
        elif step == "linkedin":
            self.linkedin = answer
        
        new_keywords = self.extract_keywords(answer)  # Using a non-async method
        self.keywords.extend(kw for kw in new_keywords if kw not in self.keywords)
        
        logger.info(f"Stored {step} data with keywords: {new_keywords}")
    
    async def clean_keywords(self) -> List[str]:
        """Clean and return the extracted keywords"""
        if not self.keywords:
            return []
            
        # Remove duplicates
        unique_keywords = list(set(self.keywords))
        
        # Filter out very common words or short words
        common_words = ['that', 'this', 'with', 'your', 'they', 'have', 'from', 'what', 'will', 'when', 'where']
        filtered_keywords = [kw for kw in unique_keywords if len(kw) > 3 and kw.lower() not in common_words]
        
        # Sort by length (longer keywords first) to prioritize more specific terms
        sorted_keywords = sorted(filtered_keywords, key=len, reverse=True)
        
        # Return top 15 keywords max
        return sorted_keywords[:15]
    
    # Getter methods for accessing stored data
    async def get_product(self) -> str:
        """Get stored product description"""
        return self.product_description
        
    async def get_market(self) -> str:
        """Get stored target market information"""
        return self.target_market
        
    async def get_differentiation(self) -> str:
        """Get stored differentiators information"""
        return self.differentiators
        
    async def get_company_size(self) -> str:
        """Get stored company stage information"""
        return self.company_stage
        
    async def get_location(self) -> str:
        """Get stored location information"""
        return self.location
        
    async def get_linkedin(self) -> str:
        """Get stored LinkedIn preference"""
        return self.linkedin
    
    async def add_conversation_entry(self, role: str, content: str):
        """Add entry to conversation history"""
        self.conversation_history.append({
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        })
        
    async def get_question(self, step: str) -> str:
        """Get question template for the current step"""
        return self.question_templates.get(step, "")
        
    async def get_next_step(self, current_step: Optional[str] = None) -> str:
        """Get the next step in the flow based on the current step and dynamic rules"""
        # Default step sequence
        steps = ['product', 'market', 'differentiation', 'company_size', 'location', 'linkedin', 'complete']
        
        if not current_step or current_step not in steps:
            return steps[0]
        
        if current_step == 'complete':
            return 'complete'
            
        # Get the latest answer for the current step for dynamic flow determination
        answer = ""
        if current_step == "product":
            answer = self.product_description
        elif current_step == "market":
            answer = self.target_market
        elif current_step == "differentiation":
            answer = self.differentiators
        elif current_step == "company_size":
            answer = self.company_stage
        elif current_step == "location":
            answer = self.location
        elif current_step == "linkedin":
            answer = self.linkedin
        
        # Use dynamic flow determination if available
        if current_step in self.dynamic_flow:
            try:
                next_step = self.dynamic_flow[current_step](answer)
                logger.info(f"Dynamically determined next step: {current_step} -> {next_step}")
                return next_step
            except Exception as e:
                logger.error(f"Error in dynamic flow determination: {str(e)}")
        
        # Fallback to sequential flow
        current_index = steps.index(current_step)
        next_index = current_index + 1
        
        logger.info(f"Sequential flow: {current_step} -> {steps[next_index] if next_index < len(steps) else 'complete'}")
        
        if next_index < len(steps):
            return steps[next_index]
        else:
            return 'complete'